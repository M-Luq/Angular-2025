This is a great summary of the Angular Routing system. Since you're using modern Angular (Signals and `provideRouter`), here are enhanced notes that organize these concepts into a logical workflow.

---

## 1. The Core Setup

In a modern Angular app, routing is initialized in `app.config.ts`.

```typescript
// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes, withComponentInputBinding()) // Enables params as @Input
  ]
};

```

## 2. Defining Routes (Static & Dynamic)

Routes are defined in an array. Order matters: the router picks the **first** match it finds.

```typescript
export const routes: Routes = [
  { path: 'tasks', component: TaskComponent }, // Static
  { path: 'users/:id', component: UserDetailComponent }, // Dynamic (:id is a placeholder)
  { path: '**', component: NotFoundComponent } // Wildcard (Must be last!)
];

```

## 3. The "Where" and "How" of Navigation

* **`<router-outlet />`**: The placeholder directive. This is where the component of the matched route is injected.
* **`routerLink`**: Used in HTML. Unlike `href`, it prevents a page refresh, keeping the application state intact.
* **`routerLinkActive`**: Automatically applies a CSS class when the link's route is active.

---

## 4. Extracting Route Parameters

When navigating to `/users/42`, you need to get that `42` inside your component.

### Method A: Component Input Binding (Recommended)

If `withComponentInputBinding()` is enabled in your config, you can treat the URL parameter like a standard input.

* **With Decorators:** `@Input() id!: string;`
* **With Signals:** `id = input.required<string>();`

### Method B: ActivatedRoute (Observable)

Use this if the component stays loaded but the parameter changes (e.g., clicking "Next User" while already on the profile page).

```typescript
private route = inject(ActivatedRoute);
userId$ = this.route.paramMap.pipe(map(params => params.get('id')));

```

---

## 5. Nested (Child) Routes

Used for layouts where part of the page stays the same (like a sidebar) while a sub-section changes.

```typescript
{
  path: 'users/:id',
  component: UserShellComponent,
  children: [
    { path: 'tasks', component: UserTasksComponent }, // URL: /users/1/tasks
    { path: 'details', component: UserDetailsComponent } // URL: /users/1/details
  ]
}

```

> **Note:** The `UserShellComponent` **must** have its own `<router-outlet>` to render the children.

---

## 6. Programmatic Navigation

When you need to navigate inside a function (e.g., after a login success):

```typescript
private router = inject(Router);
private route = inject(ActivatedRoute);

navigate() {
  // Absolute path
  this.router.navigate(['/tasks']); 

  // Relative path (moves relative to current URL)
  this.router.navigate(['details'], { relativeTo: this.route });
}

```

---

## 7. Handling "Not Found"

The **Wildcard Route** `**` catches any URL that doesn't match the paths defined above it. This is how you display a 404 page.

```typescript
{ path: '**', component: NotFoundComponent }

```

### Summary of Key Directives

| Directive | Location | Purpose |
| --- | --- | --- |
| `routerLink` | `<a>` or `<button>` | Changes the URL without refreshing. |
| `router-outlet` | Template | The "docking station" for components. |
| `routerLinkActive` | `<a>` | Adds a CSS class to the active link. |

**Would you like me to show you how to protect these routes using "Guards" (e.g., preventing access to /tasks if the user isn't logged in)?**

Overview
In Angular, the Router is "isolated" by default. A child component normally only sees the parameters defined in its own specific route segment. Setting the inheritance strategy to 'always' changes this behavior so child routes automatically inherit all parameters from their parent routes.

The Comparison
Imagine the URL: /store/:storeId/product/:productId

Default Behavior ('emptyOnly'): * The Product component can see productId.

To see storeId, you must manually access this.route.parent.

With 'always':

The Product component sees both storeId and productId directly in its own ActivatedRoute snapshot.

Key Benefits
Cleaner Code: Eliminates the need to write this.route.parent?.parent... to access data higher up in the tree.

Flat Parameter Access: Merges all path and matrix parameters into a single accessible object for the active component.

Decoupling: Components don't need to "know" exactly how many levels deep they are nested to find a specific ID.

Implementation
Add this to your provideRouter function (Standalone) or RouterModule.forRoot (Module-based):

TypeScript
// app.config.ts
provideRouter(routes, withRouterConfig({
  paramsInheritanceStrategy: 'always'
}))
[!WARNING] Naming Collisions: If a parent and child route both use the same parameter name (e.g., both use :id), the child value will overwrite the parent value in the merged object.

To round out your routing configuration, understanding how **Redirects** and **Path Matching** work‚Äîespecially in relation to the strategy we just discussed‚Äîis crucial. These ensure your users don't get lost when they hit a partial or empty URL.

---

## üöÄ Enhanced Notes: Redirects & Path Matching

In Angular, a redirect takes a user from one URL path to another. How the router "finds" that path depends on the `pathMatch` property.

### 1. `pathMatch: 'full'` (The Strict Match)

This tells the router: "Only redirect if the **entire remaining URL** is exactly equal to the path."

* **Common Use Case:** The empty string `''` path.
* **Why?** Because every URL technically starts with an empty string. If you don't use `'full'`, Angular will match **every single route** to the redirect, causing an infinite loop or blocking other routes.

```typescript
{ 
  path: '', 
  redirectTo: 'users', 
  pathMatch: 'full' 
}

```

### 2. `pathMatch: 'prefix'` (The Greedy Match)

This tells the router: "Redirect if the URL **starts with** this path."

* **Behavior:** It matches as long as the URL begins with the string provided in `path`.
* **Risk:** If used on an empty path (`path: ''`), it acts as a "catch-all" because every URL starts with nothing. This is why `'full'` is almost always preferred for empty paths.

---

## üõ† Integrating with your `userId` Logic

Looking at your specific routes, you can use redirects to make the UX much smoother. For example, if a user goes to a specific user's ID but doesn't type `/tasks`, you can force them there.

### Example Refined Configuration

```typescript
export const routes: Routes = [
  {
    path: '',
    pathMatch: 'full', // Ensures "domain.com/" goes to NoTaskComponent
    component: NoTaskComponent
  },
  {
    path: 'users/:userId',
    component: UserTasksComponent,
    children: [
      {
        path: '', // If they go to /users/123/
        redirectTo: 'tasks', // Send them to /users/123/tasks
        pathMatch: 'full'
      },
      {
        path: 'tasks',
        component: TasksComponent // Inherits :userId from parent
      },
      {
        path: 'tasks/new',
        component: NewTaskComponent
      }
    ]
  },
  {
    path: '**', // Wildcard: Matches anything not defined above
    component: NotFoundComponent
  }
];

```

---

## üí° Pro-Tips for your Notes

| Feature | Best Practice |
| --- | --- |
| **Empty Path** | Always use `pathMatch: 'full'` to avoid matching every route. |
| **Wildcard (`**`)** | Must be the **last** entry in your array. Angular matches routes in the order they are defined. |
| **Inheritance** | With `paramsInheritanceStrategy: 'always'`, even if you redirect from `users/:userId` to `users/:userId/tasks`, the child `TasksComponent` will still correctly grab the `userId`. |

> **Summary:** `pathMatch: 'full'` is like an "exact match" toggle. Without it, Angular is lazy and might trigger a redirect before the user reaches their intended destination.

This is a classic Angular distinction. The difference boils down to **persistence** vs. **instantaneous state**.

---

## üõ∞Ô∏è ActivatedRoute (The Stream)

`ActivatedRoute` is an **Observable-based** service. It is designed to stay alive while the component is initialized, even if the URL parameters change.

* **Behavior:** It provides a continuous stream of data.
* **When to use:** Use this when a user can navigate from one ID to another (e.g., from `/users/1` to `/users/2`) **without** the component being destroyed and recreated.
* **Access:** Through `this.route.params` or `this.route.paramMap` (Observables).

---

## üì∏ ActivatedRouteSnapshot (The Photo)

As the name implies, a `Snapshot` is a **static** version of the route information at a specific moment in time‚Äîspecifically, when the component was first loaded.

* **Behavior:** It is a plain JavaScript object. It does **not** update if the URL changes after the component is already on screen.
* **When to use:** Use this if you only care about the initial value when the page loads, or within **Route Guards** (`canActivate`) where you only need to check the state once.
* **Access:** Through `this.route.snapshot.params`.

---

## ‚öñÔ∏è Comparison Table

| Feature | ActivatedRoute (Observable) | ActivatedRouteSnapshot |
| --- | --- | --- |
| **Data Type** | Observable (`Observable<Params>`) | Plain Object (`Params`) |
| **Updates** | Reactive; emits new values on change. | Static; never updates after creation. |
| **Subscription** | Requires `subscribe()` or `async` pipe. | No subscription needed. |
| **Best For** | Component logic that reacts to URL changes. | Initial data fetch / Route Guards. |

---

## üõ†Ô∏è Which one fits your "Inheritance" setup?

Since you are using **Signals** and **Component Input Binding** (`userId = input.required<string>()`), Angular is actually doing the hard work for you behind the scenes!

1. **If you use Inputs/Signals:** Angular uses the **Observable** approach internally. When the URL changes from `/users/1/tasks` to `/users/2/tasks`, your `userId()` signal will update automatically, and your `computed()` tasks will re-filter instantly.
2. **If you used the Snapshot:**
```typescript
// In ngOnInit - This would ONLY work for the first user loaded.
const id = this.route.snapshot.params['userId']; 

```


If the user clicked a link to a different profile while the `TasksComponent` was already open, the `id` variable above would **not** change, and the UI would show the wrong tasks.

### Summary Note

> **Choose the Observable (`ActivatedRoute`)** whenever your component needs to be "smart" enough to refresh its data when the URL changes. **Choose the Snapshot** only when you are 100% sure the component will be destroyed/reloaded for every new set of data.

In Angular, there are two primary ways to set or update query parameters: via the **Template** (HTML) or via the **Component** (TypeScript).

Since you are already using `paramsInheritanceStrategy: 'always'`, it‚Äôs important to remember that **Query Parameters** (the stuff after the `?`) behave differently than **Path Parameters** (the stuff inside the URL path). Query parameters are global‚Äîthey are available across all routes automatically.

---

### 1. Using `routerLink` (The Template Way)

This is the easiest way to add query parameters when a user clicks a link. You use the `queryParams` attribute.

```html
<a [routerLink]="['/users', userId(), 'tasks']" 
   [queryParams]="{ sort: 'desc', filter: 'completed' }">
   View Completed Tasks
</a>

```

**Resulting URL:** `/users/123/tasks?sort=desc&filter=completed`

---

### 2. Using the `Router` (The TypeScript Way)

If you need to change the URL programmatically (e.g., after a button click or form submission), use the `Router` service.

```typescript
import { inject } from '@angular/core';
import { Router } from '@angular/router';

export class TasksComponent {
  private router = inject(Router);

  updateFilter(order: string) {
    this.router.navigate([], {
      queryParams: { sort: order },
      queryParamsHandling: 'merge', // üí° KEY: Keeps existing params
    });
  }
}

```

---

### üí° Key Configuration: `queryParamsHandling`

When navigating, you need to decide what happens to the parameters currently in the URL:

* **`'merge'`**: (Most Common) Adds the new parameters to the existing ones.
* **`'preserve'`**: Keeps the current parameters exactly as they are and ignores any new ones you provided.
* **`null` (Default)**: Replaces all current query parameters with only the new ones provided.

---

### üìä Accessing Query Params (Note)

Just like with your `userId` input, if you have `withComponentInputBinding()` enabled, you can grab query parameters directly as inputs!

```typescript
export class TasksComponent {
  // If the URL is ?sort=desc, this will automatically be 'desc'
  sort = input<string>(); 
  
  // Your existing userId from the path
  userId = input.required<string>();
}

```

---

### Summary Table: Path Params vs Query Params

| Feature | Path Params (`:id`) | Query Params (`?key=val`) |
| --- | --- | --- |
| **Location** | Part of the URL path | After the `?` |
| **Required?** | Usually Yes (for the route to match) | Always Optional |
| **Inheritance** | Controlled by `paramsInheritanceStrategy` | Global (Accessible everywhere) |
| **Use Case** | Identifying a resource (which user?) | Filtering/Sorting (how to show it?) |

To extract query parameters, you have two primary modern approaches. Since you are using **Signals** and **Input Bindings**, the first method is usually the cleanest, but the Observable method is essential if you need to perform complex data transformations.

---

## 1. Using Signal Inputs (Modern & Recommended)

If you have `withComponentInputBinding()` enabled in your router configuration, Angular automatically maps query parameters to your component inputs.

**The URL:** `/users/123/tasks?mode=edit&term=angular`

```typescript
export class TasksComponent {
  // Path parameter (:userId)
  userId = input.required<string>();

  // Query parameters (?mode=...&term=...)
  // They are treated exactly like path parameters by Input Binding
  mode = input<string>(); 
  term = input<string>();

  filteredTasks = computed(() => {
    console.log(`Searching for ${this.term()} in ${this.mode()} mode`);
    // Logic here...
  });
}

```

---

## 2. Using Observables (`ActivatedRoute`)

Use this approach if you aren't using input bindings, or if you need to combine multiple stream values (like combining path params, query params, and service data) into one stream.

```typescript
import { inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { map } from 'rxjs/operators';

export class TasksComponent {
  private route = inject(ActivatedRoute);

  // Extracting a single value as an Observable
  searchTerm$ = this.route.queryParamMap.pipe(
    map(params => params.get('term') || 'None')
  );

  // Converting to a Signal manually if needed
  searchTermSignal = toSignal(this.searchTerm$);
}

```

---

## üìù Comparison Note: Path vs. Query Params

When extracting data, keep this distinction in your notes:

| Feature | via `input()` | via `ActivatedRoute` |
| --- | --- | --- |
| **Path Params** | `userId = input()` | `route.paramMap` |
| **Query Params** | `term = input()` | `route.queryParamMap` |
| **Setup** | Needs `withComponentInputBinding()` | Works out of the box |
| **Reactivity** | Updates automatically when URL changes | Requires subscription/pipe |

---

### ‚ö†Ô∏è The "Input Name" Gotcha

If you use **Input Binding**, the name of your variable **must exactly match** the key in the URL.

* URL: `?sortOrder=asc`
* Component: `sortOrder = input<string>()` ‚úÖ
* Component: `mySort = input<string>()` ‚ùå (This will remain undefined)

---

### Summary Table: Which to use?

* **Use Inputs:** For 90% of UI logic. It's less code and fits the Signal-based architecture of modern Angular.
* **Use Observables:** When you need to use RxJS operators like `switchMap`, `debounceTime`, or `filter` before the data reaches your component logic.

That is the classic, reliable way to handle query parameters! By subscribing to `queryParams`, your component stays "awake" and reacts whenever the URL changes (e.g., from `?order=asc` to `?order=desc`) without the component needing to be destroyed and recreated.

Here are a few refined notes to level up this specific approach:

---

## üîç The Observable Approach Breakdown

### 1. `queryParams` vs `queryParamMap`

In your code, you used `queryParams`. Angular actually offers two ways to access this via the `ActivatedRoute`:

* **`queryParams` (What you used):** Returns a plain object (e.g., `{ order: 'asc' }`). You access it like a dictionary: `params['order']`.
* **`queryParamMap`:** Returns a `ParamMap` object. It is generally **preferred** because it handles missing keys more safely using `.get()` and supports multiple values for the same key using `.getAll()`.

**Refined code using `queryParamMap`:**

```typescript
this.activatedRoute.queryParamMap.subscribe({
  next: (params) => (this.order = params.get('order')), // Returns null if missing, instead of undefined
});

```

---

### 2. The Subscription "Memory Leak" Risk

When you manually `.subscribe()` in `ngOnInit`, that subscription stays active even after you leave the page unless you clean it up.

* **The Good News:** For `ActivatedRoute`, Angular is smart and usually cleans these up for you.
* **The Better Practice:** If you are using modern Angular, you can avoid manual subscriptions entirely by using **Signals** or the **Async Pipe**.

---

## üõ†Ô∏è Comparison: Manual Subscription vs. Signals

If you want to move away from manual subscriptions and leverage the same logic you used for your `userId` input, here is how they compare:

| Approach | Code Style | Reactivity |
| --- | --- | --- |
| **Your Approach** | `subscribe()` in `ngOnInit` | Manual property update |
| **Signal Input** | `order = input<string>()` | Automatic & Declarative |
| **toSignal** | `order = toSignal(this.route.queryParams)` | Cleanest for non-input logic |

### How to use `toSignal` (The Pro Way)

If you don't want to use `@Input` binding but want to avoid the `subscribe` block, you can convert the Observable directly into a Signal:

```typescript
import { toSignal } from '@angular/core/rxjs-interop';

export class TasksComponent {
  private activatedRoute = inject(ActivatedRoute);

  // Converts the Observable stream into a reactive Signal
  // 'params' will update automatically whenever the URL changes
  private params = toSignal(this.activatedRoute.queryParams);

  // Use a computed to pull the specific value
  order = computed(() => this.params()?.['order'] || 'asc');
}

```

---

### üìù Key Takeaway for your Note:

> Using `.subscribe()` on `queryParams` is perfect for **performing actions** (like calling an API) whenever a parameter changes. If you only need the value to **display or filter data** in the UI, using **Signal Inputs** or `toSignal` is generally more efficient and requires less "cleanup" code.


Here are your enhanced notes on handling Static and Dynamic data in Angular Routing.

---

## 1. Static Data: The `data` Property

The `data` property is used for passing fixed information to a route that doesn't change based on user input or API calls (e.g., page titles, breadcrumbs, or feature flags).

### Implementation

In your route configuration, you define an object for the `data` property:

```typescript
{
  path: 'users/:userId',
  component: UserTasksComponent,
  data: {
    message: "Hello!" // Static data
  }
}

```

### Accessing Static Data

* **Traditional Method:** Inject `ActivatedRoute` and access `this.route.snapshot.data['message']`.
* **Modern Method (Input Binding):** If you enable `withComponentInputBinding()` in your `provideRouter` config, you can treat route data as a standard `@Input`.

```typescript
// Inside UserTasksComponent
@Input() message?: string; 

```

---

## 2. Dynamic Data: The `resolve` Property

Resolvers are used to fetch data **before** a component is even loaded. This ensures the UI doesn't flicker or show "undefined" states while waiting for a service.

### Defining a Resolver Function

The modern approach uses the `ResolveFn`. It has access to the `ActivatedRouteSnapshot` to grab route parameters.

```typescript
export const resolveUserName: ResolveFn<string> = (
  activatedRoute: ActivatedRouteSnapshot, 
  routerState: RouterStateSnapshot
) => {
  const usersService = inject(UsersService); // Manual injection inside functions
  const userId = activatedRoute.paramMap.get('userId');
  
  return usersService.users.find(u => u.id === userId)?.name || 'Guest';
};

```

### Registering the Resolver

Add the `resolve` property to your route. It takes an object where keys are the names of the data properties you want to pass to the component.

```typescript
{
  path: 'users/:userId',
  component: UserTasksComponent,
  resolve: {
    userName: resolveUserName // Key 'userName' matches the @Input name
  }
}

```

---

## 3. Alternative: Manual Subscription (The "Old" Way)

Before Resolvers or Input Binding became the standard, we manually subscribed to `paramMap` inside `ngOnInit`. While functional, it requires more "boilerplate" and manual cleanup.

| Feature | Resolver Method | Manual Subscription |
| --- | --- | --- |
| **UX** | Component waits for data before displaying. | Component displays immediately (may need loaders). |
| **Complexity** | Cleaner component logic. | Requires `Subscription` and `OnDestroy` logic. |
| **Data Flow** | Data is ready on "arrival." | Data arrives asynchronously after the component loads. |

> **Note:** Your commented-out code shows the manual subscription method. While it works, using the `resolve` property (as shown in your `resolveUserName` function) is the preferred Angular pattern for cleaner components.

---

### Comparison Table: Data vs. Resolve

| Property | Type of Data | When is it fetched? |
| --- | --- | --- |
| **`data`** | **Static** (Hardcoded strings/objects) | Available instantly when the route is matched. |
| **`resolve`** | **Dynamic** (Fetched from Service/API) | Fetched **during** the navigation transition. |

---
Here are your enhanced notes covering **Class-based Resolvers**, **Manual Data Retrieval**, and **Dynamic Page Titles**.

---

## 1. Class-Based Resolvers (Deprecated)

Before functional resolvers (the current standard), Angular used class-based resolvers that implement the `Resolve<T>` interface.

### Implementation

```typescript
@Injectable({ providedIn: 'root' })
export class UserNameResolver implements Resolve<string> {
  constructor(private usersService: UsersService) {}

  resolve(activatedRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    return this.usersService.users.find(
      (u) => u.id === activatedRoute.paramMap.get('userId')
    )?.name || '';
  }
}

```

### Usage in Route Configuration

Instead of passing a function, you pass the class reference:

```typescript
{
  path: 'users/:userId',
  component: UserTasksComponent,
  resolve: { userName: UserNameResolver } // Angular injects the class automatically
}

```

> **Warning:** This approach is **deprecated**. Always prefer **Functional Resolvers** (using `ResolveFn`) in modern Angular (v15+) because they are lighter and support `inject()` directly.

---

## 2. Manual Data Access (Without Input Binding)

If you don't want to use `withComponentInputBinding()`, you can access both **Static (`data`)** and **Dynamic (`resolve`)** information through the `ActivatedRoute` service. Both types of data are merged into a single `data` observable.

```typescript
export class UserTasksComponent implements OnInit {
  constructor(private activatedRoute: ActivatedRoute) {}

  ngOnInit() {
    // Accessing the snapshot (non-reactive)
    const staticMsg = this.activatedRoute.snapshot.data['message'];
    const resolvedName = this.activatedRoute.snapshot.data['userName'];

    // Accessing via Observable (reactive to changes)
    this.activatedRoute.data.subscribe(data => {
      console.log(data['message']);  // Static
      console.log(data['userName']); // Dynamic
    });
  }
}

```

---

## 3. Controlling Resolver Execution

By default, resolvers only re-run when **Route Parameters** change (e.g., `:userId`). They do **not** re-run if only **Query Parameters** (e.g., `?sort=desc`) change.

To change this behavior, use the `runGuardsAndResolvers` property:

| Value | Behavior |
| --- | --- |
| `paramsChange` (Default) | Re-runs only if path parameters change. |
| `paramsOrQueryParamsChange` | Re-runs if `:userId` OR `?query` changes. |
| `always` | Re-runs every time the route is technically "activated," even if the parameters are the same. |

**Example:**

```typescript
{
  path: 'users/:userId',
  component: UserTasksComponent,
  resolve: { userName: resolveUserName },
  runGuardsAndResolvers: 'always' // Force refresh
}

```

---

## 4. Resolving Page Titles

Angular provides a built-in way to update the browser tab title dynamically.

### Static Title

```typescript
{
  path: 'settings',
  component: SettingsComponent,
  title: 'User Settings' // Tab shows: User Settings
}

```

### Dynamic Title (Using ResolveFn)

You can use a function to generate a title based on route data:

```typescript
export const resolveTitle: ResolveFn<string> = (route) => {
  return `Profile of ${route.paramMap.get('userId')}`;
};

// In Route:
{
  path: 'users/:userId',
  component: UserTasksComponent,
  title: resolveTitle // Tab shows: Profile of 123
}

```

Implementing Route Guards allows you to control whether a user can navigate to, stay on, or leave a specific part of your application. While `canActivate` is common, `canMatch` is often considered more versatile for advanced routing scenarios.

---

## 1. The Versatile `canMatch` Guard

`canMatch` is powerful because it determines if a route should even be considered. If it returns `false`, Angular acts as if that route doesn't exist and keeps looking for other matches in the configuration.

### Functional Implementation (Modern)

This is the recommended approach. It takes the `Route` object and `UrlSegment[]`.

```typescript
export const canMatchTeam: CanMatchFn = (route, segments) => {
  const router = inject(Router);
  const shouldAccess = Math.random() > 0.5;

  if (shouldAccess) {
    return true;
  }
  // Use RedirectCommand to send users elsewhere
  return new RedirectCommand(router.parseUrl('/unauthorized'));
};

```

### Why use `canMatch` over `canActivate`?

* **Multiple Routes for one Path:** You can define the same path twice with different guards (e.g., an Admin Dashboard and a User Dashboard on the same URL).
* **Performance:** It prevents the router from even attempting to load component code if the conditions aren't met.

---

## 2. Preventing Data Loss: `canDeactivate`

This guard is triggered when a user tries to **leave** a route. It‚Äôs perfect for "Unsaved Changes" warnings.

### Implementation Example

```typescript
export const canLeaveEditPage: CanDeactivateFn<NewTaskComponent> = (component) => {
  if (component.hasUnsavedChanges()) {
    return window.confirm("You have unsaved changes. Do you really want to leave?");
  }
  return true;
};

```

---

## 3. Class-Based Guards (Legacy)

As you noted, these are **deprecated**. They require more boilerplate because you must implement an interface and provide the class in the root injector.

```typescript
@Injectable({ providedIn: 'root' })
class CanMatchTeamSection implements CanMatch {
  constructor(private router: Router) {}
  canMatch(route: Route, segments: UrlSegment[]) {
    // Logic here...
    return true; 
  }
}

```

**Route Configuration for both types:**

```typescript
{
  path: 'tasks/new',
  component: NewTaskComponent,
  canMatch: [canMatchTeam],     // Functional
  canDeactivate: [canLeaveEditPage] // Functional
}

```

---

## 4. Summary of Guard Types

| Guard | Purpose | Common Use Case |
| --- | --- | --- |
| **`canMatch`** | Can this route be used at all? | Feature flagging or Role-based pathing. |
| **`canActivate`** | Can the user access this page? | Basic Authentication checks. |
| **`canActivateChild`** | Can the user access child routes? | Protecting an entire administrative section. |
| **`canDeactivate`** | Can the user leave this page? | "Discard changes?" confirmation dialogs. |

---

### Pro-Tip: The `RedirectCommand`

In modern Angular, you no longer need to manually call `router.navigate()` inside a guard and return `false`. You can simply return a `RedirectCommand(UrlTree)`, which tells Angular: "Don't just stop navigation, go here instead."



